require(Rcpp)
require(RcppArmadillo)


   
    NumericVector prob = cumsum( as_vector( P/psum ) ) ;
    NumericVector time_increment = -(1/Ptotal)*log( runif ( nsimultaneous_picks ) ) ; 
      
     


======================= rcpp version of the ssa.engine


require(Rcpp)
sourceCpp( rebuild=TRUE, code='
#include <Rcpp.h>

// inline int randWrapper(const int n) { return floor(unif_rand()*n); }
using namespace std;
using namespace Rcpp;
// [[Rcpp::export]]

List ssa_engine_rcpp ( List p, List res ) {

  int tio = 0 ; // internal time counters to trigger data output (disk saves)
  int tout = 0 ;

  // extract params from p
  int tend = as<int>( p["monitor"] ) ;
  int nsimultaneous_picks = as<int>(p["nsimultaneous.picks"]) ;
  int nP =  as<int>(p["nP"]) ;
  IntegerVector iP = seq_len( nP ) ;

  // extract variables from res
  NumericMatrix X = as<NumericMatrix>( res["X"] ) ;
  arma::cube P ( as<NumericVector>( res["P"] ).begin(), as<int>(p["nr"]),  as<int>(p["nc"]), as<int>(p["np"]) ) ;
 
  double Ptotal = as<double>( res["P.total"] ) ;

  int simtime = 0 ;

  while ( simtime < tend ) {
  
    # pre-caluclate these factor outside of the loop as they change slowly
    
    # choose reaction times
      tn = insp  ## created as a vector in list p to speed it up a little
      nt = nsimultaneous.picks
      time_increment = rexp(nt, Ptotal )
      tnew = res$simtime + sum( time_increment )
      
      # check if truncation required 
      if ( tnew > tout ) {
        tn = which(  cumsum( time_increment ) <= tout ) 
        nt = length (tn)
        time_increment = time_increment[ tn ]
        tnew = res$simtime + sum( time_increment )
      }
 
      if (nt > 0 ) {
        # choose reactions

// sample reactions
//   i.e.:: J = ssa_sample_direct( cumsum( res$P[])/res$P.total, sort( runif ( nt ) ) )

  int np = probs.size() ;
  NumericVector rn = runif( nt ) ; 
  IntegerVector J(nt) ;
	int j=0 ;
  int i=0 ;
  std::sort(rn.begin(), rn.end());
  while( i < nt ) {  // cycle over random numbers and classify reaction in sequence
    while ( j < np &&  i < nt ) {
      if ( rn[i] < probs[j] ) { 
        J[i] = j+1 ;   // +1 as C uses 0 as first index
        i++ ;
      } else {
        j++ ;
      }
    }
    j++ ;
  }


        # remap random element to correct location and process
        jn  = floor( (J-1)/nrc ) + 1  # which reaction process
        jj = J - (jn-1)*nrc  # which cell 
        # determine focal cell coords
        cc = floor( (jj-1)/nr ) + 1   # col
        cr = jj - (cc-1) * nr         # row

        for ( w in tn ) {
          o = NU[[ jn[w] ]]  
          # no = dim(o)[1]  # nrows = # operations (ie, unary, or binary)
          ro = cr[w] + o[,1]  # row of the focal cell
          co = cc[w] + o[,2]  # column of the focal cell
          # OP = o[,3] # operation upon the state variable
          # ensure boundary conditions are sane (reflective boundary conditions)
          ro[ro < 1] = 2
          ro[ro > nr] = nr_1
          co[co < 1] = 2
          co[co > nc] = nc_1 
          # determine the appropriate operations for the reaction and their 'real' locations
          # build correctly structured indices 
          ix = .Internal( cbind( deparse.level=1, ro, co))   ## row, column in X .. Internal speeds up 26%
          ip = .Internal( cbind( deparse.level=1, ro, co, po[[length(ro)]] ) )  # rows and columns in P 
          # update state space and associated propensities in cells where state has changed, etc
          
          res$X[ix] = XX = .Internal( pmax( na.rm=FALSE, 0, res$X[ix] + o[,3] ))
          res$P[ip] = RE( p, X=XX, ix=ix ) 
        }  # end for

        res$P.total = sum( res$P )
        res$simtime = tnew
        res$nevaluations = res$nevaluations + nt
      }

      if ( tnew >= tout ) {
        tout = tout + t.censusinterval 
        tio = tio + 1  # time as index
        # print( P.total - sum(P[]) ) # debug
        ssa.db( ptype="save", out=res$X[], tio=tio, outdir=outdir, rn=rn )  
        # res$P.total = sum(res$P[]) # reset P.total in case of divergence due to floating point errors
        # browser()
        if (monitor) {
          # res$P = RE( p, res$X ) # full refresh of propensities in case of numerical drift
          cat( paste( tio, res$nevaluations, round(sum(res$X)), round(res$P.total), Sys.time(), sep="\t\t" ), "\n" )
          image( res$X[], col=heat.colors(100)  )
          assign( "res", res, pos=1 ) # update the res output in the gloabl environment in case a restart is necessary
        }
      }
   
    }  // end for
  
  } // end while

  return List::create( _["X"]=X, _["P"]=P, _["P.total"]=Ptotal) ;

}

')









require(rbenchmark)
benchmark( test4(p,res), test5(p,res), replications=1 )


require(rbenchmark)
> benchmark( test4(p,res), test5(p,res), replications=1 )
Note: no visible binding for global variable 'nP' 
           test replications elapsed relative user.self sys.self user.child sys.child
1 test4(p, res)            1  63.081    1.000    62.819    0.006          0         0
2 test5(p, res)            1 117.400    1.861   116.901    0.013          0         0
> 


test4 = function( p, res ) {
  # optimized and some minor approximations 
  res <- with (p, { 
      # pre-caluclate these factor outside of the loop as they change slowly
      # prop = .Internal(pmax(na.rm=FALSE, 0, res$P[]/res$P.total ) )
      prop = cumsum( res$P[]/res$P.total )
      J = as.vector( ssa_sample_direct( as.vector(prop), sort( runif(nsimultaneous.picks)) )) 
      } )
}



test5 = function( p, res ) {
  # optimized and some minor approximations 
  res <- with (p, { 
      # pre-caluclate these factor outside of the loop as they change slowly
      # prop = .Internal(pmax(na.rm=FALSE, 0, res$P[]/res$P.total ) )
      prop = res$P[]/res$P.total
      J = .Internal(sample( nP, size=nsimultaneous.picks, replace=FALSE, prob=prop ) ) 
      } )
}


test6 = function( p, res ) {
  # optimized and some minor approximations 
  res <- with (p, { 
      # pre-caluclate these factor outside of the loop as they change slowly
      # prop = .Internal(pmax(na.rm=FALSE, 0, res$P[]/res$P.total ) )
      J = unlist( lapply( runif(nsimultaneous.picks)*res$P.total,
        FUN=function(x, pr) (which( pr >= x) [1]) , pr=cumsum(res$P[]) ) )

      } )
}



test7 = function( p, res ) {
  # optimized and some minor approximations 
  res <- with (p, { 
      # pre-caluclate these factor outside of the loop as they change slowly
      # prop = .Internal(pmax(na.rm=FALSE, 0, res$P[]/res$P.total ) )
      prop = res$P[]/res$P.total
      J = .Internal(sample( nP, size=nsimultaneous.picks, replace=FALSE, prob=prop ) ) 
      time.increment = -(1/res$P.total)*log( runif ( nsimultaneous.picks ) ) 
     # remap random element to correct location and process
      jn  = floor( (J-1)/nrc ) + 1  # which reaction process
      jj = J - (jn-1)*nrc  # which cell 
      # determine focal cell coords
      cc = floor( (jj-1)/nr ) + 1   # col
      cr = jj - (cc-1) * nr         # row
      
      tnew = res$simtime + sum( time.increment )
      tn = 1:nsimultaneous.picks
       for ( w in tn ) {
        o = NU[[ jn[w] ]]  
        # no = dim(o)[1]  # nrows = # operations (ie, unary, or binary)
        ro = cr[w] + o[,1]  # row of the focal cell
        co = cc[w] + o[,2]  # column of the focal cell
        # OP = o[,3] # operation upon the state variable
        # ensure boundary conditions are sane (reflective boundary conditions)
        ro[ro < 1] = 2
        ro[ro > nr] = nr_1
        co[co < 1] = 2
        co[co > nc] = nc_1 
        # determine the appropriate operations for the reaction and their 'real' locations
        # build correctly structured indices 
        ix = .Internal( cbind( deparse.level=1, ro, co))   ## row, column in X .. Internal speeds up 26%
        ip = .Internal( cbind( deparse.level=1, ro, co, po[[length(ro)]] ) )  # rows and columns in P 
        # update state space and associated propensities in cells where state has changed, etc
        res$X[ix] = XX = .Internal( pmax( na.rm=FALSE, 0, res$X[ix] + o[,3] ))
     
        res$P[ip] = RE( p, X=XX, ix=ix ) 
      }  # end for


      } )
}



library(inline)
require(RcppArmadillo)




sourceCpp( rebuild=TRUE, code='
#include <RcppArmadillo.h>
using namespace Rcpp;
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export]]
IntegerVector ssa_quicksample( NumericVector pr0, NumericVector rn0 ) {
  arma::vec pr = Rcpp::as<arma::vec>(pr0); 
  arma::vec rn = Rcpp::as<arma::vec>(rn0); 
  int s = rn.size() ;
  arma::uvec J = arma::zeros<arma::uvec>(s); 
  arma::uvec o;
	for ( int it=0; it < s; it++ ) {
    J[it] = arma::as_scalar( arma::find( pr >= rn[it], 1, "first" ) ) ;
  }
  return( wrap( J ) ) ;
}
')







sourceCpp( rebuild=TRUE, code='
#include <RcppArmadillo.h>
using namespace Rcpp;
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export]]
IntegerVector quicksample( NumericVector pr, NumericVector rns ) {
  int s = rns.size() ;
	for ( int it=0; it < s; it++ ) {
		J(it) = arma::find( pr >= rns(it), 1, "first" ) ;
  }
  return( wrap( as<IntegerVector>(J) ) ) ;
}
')




sourceCpp( rebuild=TRUE, code='
//#include <Rcpp.h>
#include <RcppArmadilloExtensions/sample.h>
#include <boost/array.hpp>  // eg. to additionally use boost libraries, etc.
using namespace Rcpp;
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export]]
NumericVector test4( List p, List res ) {
  RNGScope scope ;
  Function as_vector( "as.vector" ) ;
  //Function r_cumsum( "cumsum" ) ;
  //Function r_sort( "sort" ) ;
  //Function r_sample("sample") ;  // load the R function to make this easier -- speed is equal to the Armadillo version
  
  int tend = as<int>( p["monitor"] ) ;
  int nsimultaneous_picks = as<int>(p["nsimultaneous.picks"]) ;
  int nP =  as<int>(p["nP"]) ;
  IntegerVector iP = seq_len( nP ) ; //sugar
  NumericMatrix X = as<NumericMatrix>( res["X"] ) ;
  NumericVector Pvec = as<NumericVector>( res["P"] ) ;
  arma::cube P ( as<NumericVector>( res["P"] ).begin(), as<int>(p["nr"]),  as<int>(p["nc"]), as<int>(p["np"]) ) ;
  double Ptotal = as<double>( res["P.total"] ) ;
  double psum = accu(P) ;  // accumulate is the summing function for cubes and matrices in Armadillo 
  
  // NumericVector prop = as_vector( P/psum )  ;
  
  
  NumericVector cumP = Rf_cumsum( as_vector( P ) )  ;
  NumericVector run1 = Rf_sort( runif( nsimultaneous_picks ) ) ;  // sugar and R 
  IntegerVector J( nsimultaneous_picks ) ; 
  
	for ( it=0; it<nsimultaneous_picks; it++ ) {
		J[ it ] = find( cumP >= run1[ it ], 1, "first" );
  }
  
  return( wrap( J ) ) ;

  // find( cumP >= sample( iP, nsimultaneous_picks, FALSE, prop) ;
  // NumericVector J = sample( iP, nsimultaneous_picks, FALSE, prop) ;
  //NumericVector J = RcppArmadillo::sample( iP, nsimultaneous_picks, FALSE, prop ) ;
  //NumericVector time_increment = -(1/Ptotal)*log( runif ( nsimultaneous_picks ) ) ;  
  //return ( wrap( cumP ) ) ;
}
')




sourceCpp( rebuild=TRUE, code='
#include <Rcpp.h>
//#include <RcppArmadilloExtensions/sample.h>
//#include <boost/array.hpp>  // eg. to additionally use boost libraries, etc.
using namespace Rcpp;
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export]]
NumericVector test9( List p, List res ) {
  RNGScope scope ;
  Function as_vector( "as.vector" ) ;
  Function r_seq( "seq" ) ;
  Function sample("sample") ;  // load the R function to make this easier -- speed is equal to the Armadillo version
  
  int tend = as<int>( p["monitor"] ) ;
  int nsimultaneous_picks = as<int>(p["nsimultaneous.picks"]) ;
  int nP =  as<int>(p["nP"]) ;
  NumericVector iP = r_seq( nP ) ;
  NumericMatrix X = as<NumericMatrix>( res["X"] ) ;
  NumericVector Pvec = as<NumericVector>( res["P"] ) ;
  arma::cube P ( as<NumericVector>( res["P"] ).begin(), as<int>(p["nr"]),  as<int>(p["nc"]), as<int>(p["np"]) ) ;
  double Ptotal = as<double>( res["P.total"] ) ;
  double psum = accu(P) ;  // accumulate is the summing function for cubes and matrices in Armadillo 
  
  NumericVector cumP = cumsum( as_vector( P ) )  ;

  
  // NumericVector J = sample( iP, nsimultaneous_picks, FALSE, prop) ;
  // NumericVector J = RcppArmadillo::sample( iP, nsimultaneous_picks, FALSE, prop ) ;
  //NumericVector time_increment = -(1/Ptotal)*log( runif ( nsimultaneous_picks ) ) ;  
  return ( wrap( cumP ) ) ;
}
')



 
# find first reaction channel from an SSA .. two versions ... ssa_sample_direct is the fastest



# FASTEST -- directly use C++
require(Rcpp)
sourceCpp( rebuild=TRUE, code='
#include <Rcpp.h>

// inline int randWrapper(const int n) { return floor(unif_rand()*n); }
using namespace std;
using namespace Rcpp;
// [[Rcpp::export]]
IntegerVector ssa_sample_direct( NumericVector probs, NumericVector rn ) {
  int np = probs.size() ;
  int num = rn.size() ;
  IntegerVector J(num) ;
	int j=0 ;
  int i=0 ;
  std::sort(rn.begin(), rn.end());
  while( i < num ) {  // cycle over random numbers and classify reaction in sequence
    while ( j < np &&  i < num ) {
      if ( rn[i] < probs[j] ) { 
        // debug
        // Rcpp::Rcout << i << " " << j << " " << rn[i] << " " << probs[j] << " \\n " ;
        J[i] = j+1 ;   // +1 as C uses 0 as first index
        i++ ;
      } else {
        j++ ;
      }
    }
    j++ ;
  }
  // random_shuffle(J.begin(), J.end(), randWrapper);  //randomize order
  return( wrap( J ) );  
}
')



debug = FALSE
if ( debug) {
  v = cumsum(runif(20))
  v = v/max(v)
  ru = runif(10) 
  rno = order( ru)
  ssa_sample_direct( v, sort(ru ) )
  for (i in 1:10000) ssa_sample_direct( v, sort(ru ) )
}





