require(Rcpp)
require(RcppArmadillo)



NumericVector SysStateUpdate( List p, List res ) {

  // note that Rcpp encodes many basic R-functions including pmax, log, floor, etc 
  // and, math and query operators are mostly also fully vectorized
  // working with NAs seems to be a bit of a pain
  // also the assertion *** noNA(x) *** can make some functions faster!
  // pmax is slower than using std::max()  by ~ 1.5-2X

 
  // load the R function to make this easier -- speed is generally equal to the Armadillo version
  Function as_vector( "as.vector" ) ;
  Function sample("sample") ;  
  

  int tio = 0 ;
  int tout = 0 ;
  int tend = as<int>( p["monitor"] ) ;
  
  // extract params from p
  int nsimultaneous_picks = as<int>(p["nsimultaneous.picks"]) ;
  int nP =  as<int>(p["nP"]) ;
  IntegerVector iP = seq_len( nP ) ;

  // extract vaiables from res
  NumericMatrix X = as<NumericMatrix>( res["X"] ) ;
  arma::cube P ( as<NumericVector>( res["P"] ).begin(), as<int>(p["nr"]),  as<int>(p["nc"]), as<int>(p["np"]) ) ;
 
  double Ptotal = as<double>( res["P.total"] ) ;

  int simtime = 0 ;
  while ( simtime < tend ) {
    
    NumericVector prop = as_vector( P/psum )  ;
    NumericVector J = sample( iP, nsimultaneous_picks, 0, prop) ;
    NumericVector time_increment = -(1/Ptotal)*log( runif ( nsimultaneous_picks ) ) ; 
      
    // # remap random element to correct location and process
      jn  = floor( (J-1)/nrc ) + 1  ;  // which reaction process
      jj = J - (jn-1)*nrc ; // # which cell 
    // # determine focal cell coords
      cc = floor( (jj-1)/nr ) + 1  ;  // # col
      cr = jj - (cc-1) * nr        ;  // # row
      
      tnew = res$simtime + sum( time.increment ) ; 
      tn = 1:nsimultaneous.picks ;
 
      if ( tnew > tout ) {
        tcs = cumsum( time.increment )  ;
        tn = which( tcs <= tout )  ;
        time.increment = time.increment[ tn ] ;
        outputdata = TRUE ;
      }

     for ( int it = 0; it < ie; ++it ) {  // it = "simtime"; ie = "t.end"

      out[i] = sqrt(pow(ys[i] - x, 2.0)) ;
      
      for ( w in tn ) {
        
        o = NU[[ jn[w] ]]  
        # no = dim(o)[1]  # nrows = # operations (ie, unary, or binary)
        ro = cr[w] + o[,1]  # row of the focal cell
        co = cc[w] + o[,2]  # column of the focal cell
        # OP = o[,3] # operation upon the state variable
        # ensure boundary conditions are sane (reflective boundary conditions)
        ro[ro < 1] = 2
        ro[ro > nr] = nr_1
        co[co < 1] = 2
        co[co > nc] = nc_1 
        # determine the appropriate operations for the reaction and their 'real' locations
        # build correctly structured indices 
        ix = .Internal( cbind( deparse.level=1, ro, co))   ## row, column in X .. Internal speeds up 26%
        ip = .Internal( cbind( deparse.level=1, ro, co, po[[length(ro)]] ) )  # rows and columns in P 
        # update state space and associated propensities in cells where state has changed, etc
        
        res$X[ix] = XX = .Internal( pmax( na.rm=FALSE, 0, res$X[ix] + o[,3] ))
        res$P[ip] = RE( p, X=XX, ix=ix ) 
      }  # end for

      res$P.total = sum( res$P )
      res$simtime = res$simtime + sum(time.increment)
      res$nevaluations = res$nevaluations + length(time.increment)


   
    }  // end for
  
  } // end while
    return List::create( _["X"]=X, _["P"]=P, _["P.total"]=Ptotal) ;
}
 



')








ssa.engine.approximation = function( p, res ) {
  # optimized and some minor approximations 
  res <- with (p, { 
    
    tio = tout = 0  # internal time counters to trigger data output (disk saves)
    
    if (monitor) {
      on.exit( return(res) )  # in case we need to restart the sim with the last run
      # cat( paste( tio, res$nevaluations, round(su:e m(res$X)), round(res$P.total), Sys.time(), sep="\t\t" ), "\n" )
      # image( res$X[], col=heat.colors(100)  )
    } else {
      on.exit( browser())   # to debug
    }
    
    while (res$simtime <= t.end )  {
      # pre-caluclate these factor outside of the loop as they change slowly
      # prop = .Internal(pmax(na.rm=FALSE, 0, res$P[]/res$P.total ) )
      prop = res$P[]/res$P.total
      J = vector( "integer", length=p$nsimultaneous.picks )
      pr = cumsum( prop ) 
      rlist = runif( p$nsimultaneous.picks )
      for (o in 1:p$nsimultaneous.picks  ) {
        print(o)
        J[o] = which.min( abs( pr-rlist[o] ) )  
      }



      
      J = .Internal(sample( nP, size=nsimultaneous.picks, replace=FALSE, prob=prop ) ) 
      time.increment = -(1/res$P.total)*log( runif ( nsimultaneous.picks ) ) 
      # remap random element to correct location and process
      jn  = floor( (J-1)/nrc ) + 1  # which reaction process
      jj = J - (jn-1)*nrc  # which cell 
      # determine focal cell coords
      cc = floor( (jj-1)/nr ) + 1   # col
      cr = jj - (cc-1) * nr         # row
      
      tnew = res$simtime + sum( time.increment )
      tn = 1:nsimultaneous.picks
      
      if ( tnew > tout ) {
        tcs = cumsum( time.increment )
        tn = which( tcs <= tout ) 
        time.increment = time.increment[ tn ]
        outputdata = TRUE
      }

      
      for ( w in tn ) {
        
        o = NU[[ jn[w] ]]  
        # no = dim(o)[1]  # nrows = # operations (ie, unary, or binary)
        ro = cr[w] + o[,1]  # row of the focal cell
        co = cc[w] + o[,2]  # column of the focal cell
        # OP = o[,3] # operation upon the state variable
        # ensure boundary conditions are sane (reflective boundary conditions)
        ro[ro < 1] = 2
        ro[ro > nr] = nr_1
        co[co < 1] = 2
        co[co > nc] = nc_1 
        # determine the appropriate operations for the reaction and their 'real' locations
        # build correctly structured indices 
        ix = .Internal( cbind( deparse.level=1, ro, co))   ## row, column in X .. Internal speeds up 26%
        ip = .Internal( cbind( deparse.level=1, ro, co, po[[length(ro)]] ) )  # rows and columns in P 
        # update state space and associated propensities in cells where state has changed, etc
        
        res$X[ix] = XX = .Internal( pmax( na.rm=FALSE, 0, res$X[ix] + o[,3] ))
        res$P[ip] = RE( p, X=XX, ix=ix ) 
      }  # end for

      res$P.total = sum( res$P )
      res$simtime = res$simtime + sum(time.increment)
      res$nevaluations = res$nevaluations + length(time.increment)

      if ( outputdata ) {
        tout = tout + t.censusinterval 
        tio = tio + 1  # time as index
        # print( P.total - sum(P[]) ) # debug
        outputdata = FALSE
        ssa.db( ptype="save", out=res$X[], tio=tio, outdir=outdir, rn=rn )  
        # res$P.total = sum(res$P[]) # reset P.total in case of divergence due to floating point errors
        # browser()
        if (monitor) {
          # res$P = RE( p, res$X ) # full refresh of propensities in case of numerical drift
          cat( paste( tio, res$nevaluations, round(sum(res$X)), round(res$P.total), Sys.time(), sep="\t\t" ), "\n" )
          image( res$X[], col=heat.colors(100)  )
          assign( "res", res, pos=1 ) # update the res output in the gloabl environment in case a restart is necessary
        }
      }

    } # end while 
    return(res)
  })  # end repeat and within
  return(res)
}




-------------------- tests ---------------


 -------



require(rbenchmark)
benchmark( test4(p,res), test5(p,res), replications=1 )


require(rbenchmark)
> benchmark( test4(p,res), test5(p,res), replications=1 )
Note: no visible binding for global variable 'nP' 
           test replications elapsed relative user.self sys.self user.child sys.child
1 test4(p, res)            1  63.081    1.000    62.819    0.006          0         0
2 test5(p, res)            1 117.400    1.861   116.901    0.013          0         0
> 


test4 = function( p, res ) {
  # optimized and some minor approximations 
  res <- with (p, { 
      # pre-caluclate these factor outside of the loop as they change slowly
      # prop = .Internal(pmax(na.rm=FALSE, 0, res$P[]/res$P.total ) )
      prop = cumsum( res$P[]/res$P.total )
      J = as.vector( ssa_sample_direct( as.vector(prop), sort( runif(nsimultaneous.picks)) )) 
      } )
}



test5 = function( p, res ) {
  # optimized and some minor approximations 
  res <- with (p, { 
      # pre-caluclate these factor outside of the loop as they change slowly
      # prop = .Internal(pmax(na.rm=FALSE, 0, res$P[]/res$P.total ) )
      prop = res$P[]/res$P.total
      J = .Internal(sample( nP, size=nsimultaneous.picks, replace=FALSE, prob=prop ) ) 
      } )
}


test6 = function( p, res ) {
  # optimized and some minor approximations 
  res <- with (p, { 
      # pre-caluclate these factor outside of the loop as they change slowly
      # prop = .Internal(pmax(na.rm=FALSE, 0, res$P[]/res$P.total ) )
      J = unlist( lapply( runif(nsimultaneous.picks)*res$P.total,
        FUN=function(x, pr) (which( pr >= x) [1]) , pr=cumsum(res$P[]) ) )

      } )
}



test7 = function( p, res ) {
  # optimized and some minor approximations 
  res <- with (p, { 
      # pre-caluclate these factor outside of the loop as they change slowly
      # prop = .Internal(pmax(na.rm=FALSE, 0, res$P[]/res$P.total ) )
      prop = res$P[]/res$P.total
      J = .Internal(sample( nP, size=nsimultaneous.picks, replace=FALSE, prob=prop ) ) 
      time.increment = -(1/res$P.total)*log( runif ( nsimultaneous.picks ) ) 
     # remap random element to correct location and process
      jn  = floor( (J-1)/nrc ) + 1  # which reaction process
      jj = J - (jn-1)*nrc  # which cell 
      # determine focal cell coords
      cc = floor( (jj-1)/nr ) + 1   # col
      cr = jj - (cc-1) * nr         # row
      
      tnew = res$simtime + sum( time.increment )
      tn = 1:nsimultaneous.picks
       for ( w in tn ) {
        o = NU[[ jn[w] ]]  
        # no = dim(o)[1]  # nrows = # operations (ie, unary, or binary)
        ro = cr[w] + o[,1]  # row of the focal cell
        co = cc[w] + o[,2]  # column of the focal cell
        # OP = o[,3] # operation upon the state variable
        # ensure boundary conditions are sane (reflective boundary conditions)
        ro[ro < 1] = 2
        ro[ro > nr] = nr_1
        co[co < 1] = 2
        co[co > nc] = nc_1 
        # determine the appropriate operations for the reaction and their 'real' locations
        # build correctly structured indices 
        ix = .Internal( cbind( deparse.level=1, ro, co))   ## row, column in X .. Internal speeds up 26%
        ip = .Internal( cbind( deparse.level=1, ro, co, po[[length(ro)]] ) )  # rows and columns in P 
        # update state space and associated propensities in cells where state has changed, etc
        res$X[ix] = XX = .Internal( pmax( na.rm=FALSE, 0, res$X[ix] + o[,3] ))
     
        res$P[ip] = RE( p, X=XX, ix=ix ) 
      }  # end for


      } )
}



library(inline)
require(RcppArmadillo)




sourceCpp( rebuild=TRUE, code='
#include <RcppArmadillo.h>
using namespace Rcpp;
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export]]
IntegerVector ssa_quicksample( NumericVector pr0, NumericVector rn0 ) {
  arma::vec pr = Rcpp::as<arma::vec>(pr0); 
  arma::vec rn = Rcpp::as<arma::vec>(rn0); 
  int s = rn.size() ;
  arma::uvec J = arma::zeros<arma::uvec>(s); 
  arma::uvec o;
	for ( int it=0; it < s; it++ ) {
    J[it] = arma::as_scalar( arma::find( pr >= rn[it], 1, "first" ) ) ;
  }
  return( wrap( J ) ) ;
}
')







sourceCpp( rebuild=TRUE, code='
#include <RcppArmadillo.h>
using namespace Rcpp;
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export]]
IntegerVector quicksample( NumericVector pr, NumericVector rns ) {
  int s = rns.size() ;
	for ( int it=0; it < s; it++ ) {
		J(it) = arma::find( pr >= rns(it), 1, "first" ) ;
  }
  return( wrap( as<IntegerVector>(J) ) ) ;
}
')




sourceCpp( rebuild=TRUE, code='
//#include <Rcpp.h>
#include <RcppArmadilloExtensions/sample.h>
#include <boost/array.hpp>  // eg. to additionally use boost libraries, etc.
using namespace Rcpp;
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export]]
NumericVector test4( List p, List res ) {
  RNGScope scope ;
  Function as_vector( "as.vector" ) ;
  //Function r_cumsum( "cumsum" ) ;
  //Function r_sort( "sort" ) ;
  //Function r_sample("sample") ;  // load the R function to make this easier -- speed is equal to the Armadillo version
  
  int tend = as<int>( p["monitor"] ) ;
  int nsimultaneous_picks = as<int>(p["nsimultaneous.picks"]) ;
  int nP =  as<int>(p["nP"]) ;
  IntegerVector iP = seq_len( nP ) ; //sugar
  NumericMatrix X = as<NumericMatrix>( res["X"] ) ;
  NumericVector Pvec = as<NumericVector>( res["P"] ) ;
  arma::cube P ( as<NumericVector>( res["P"] ).begin(), as<int>(p["nr"]),  as<int>(p["nc"]), as<int>(p["np"]) ) ;
  double Ptotal = as<double>( res["P.total"] ) ;
  double psum = accu(P) ;  // accumulate is the summing function for cubes and matrices in Armadillo 
  
  // NumericVector prop = as_vector( P/psum )  ;
  
  
  NumericVector cumP = Rf_cumsum( as_vector( P ) )  ;
  NumericVector run1 = Rf_sort( runif( nsimultaneous_picks ) ) ;  // sugar and R 
  IntegerVector J( nsimultaneous_picks ) ; 
  
	for ( it=0; it<nsimultaneous_picks; it++ ) {
		J[ it ] = find( cumP >= run1[ it ], 1, "first" );
  }
  
  return( wrap( J ) ) ;

  // find( cumP >= sample( iP, nsimultaneous_picks, FALSE, prop) ;
  // NumericVector J = sample( iP, nsimultaneous_picks, FALSE, prop) ;
  //NumericVector J = RcppArmadillo::sample( iP, nsimultaneous_picks, FALSE, prop ) ;
  //NumericVector time_increment = -(1/Ptotal)*log( runif ( nsimultaneous_picks ) ) ;  
  //return ( wrap( cumP ) ) ;
}
')




sourceCpp( rebuild=TRUE, code='
#include <Rcpp.h>
//#include <RcppArmadilloExtensions/sample.h>
//#include <boost/array.hpp>  // eg. to additionally use boost libraries, etc.
using namespace Rcpp;
// [[Rcpp::depends(RcppArmadillo)]]
// [[Rcpp::export]]
NumericVector test9( List p, List res ) {
  RNGScope scope ;
  Function as_vector( "as.vector" ) ;
  Function r_seq( "seq" ) ;
  Function sample("sample") ;  // load the R function to make this easier -- speed is equal to the Armadillo version
  
  int tend = as<int>( p["monitor"] ) ;
  int nsimultaneous_picks = as<int>(p["nsimultaneous.picks"]) ;
  int nP =  as<int>(p["nP"]) ;
  NumericVector iP = r_seq( nP ) ;
  NumericMatrix X = as<NumericMatrix>( res["X"] ) ;
  NumericVector Pvec = as<NumericVector>( res["P"] ) ;
  arma::cube P ( as<NumericVector>( res["P"] ).begin(), as<int>(p["nr"]),  as<int>(p["nc"]), as<int>(p["np"]) ) ;
  double Ptotal = as<double>( res["P.total"] ) ;
  double psum = accu(P) ;  // accumulate is the summing function for cubes and matrices in Armadillo 
  
  NumericVector cumP = cumsum( as_vector( P ) )  ;

  
  // NumericVector J = sample( iP, nsimultaneous_picks, FALSE, prop) ;
  // NumericVector J = RcppArmadillo::sample( iP, nsimultaneous_picks, FALSE, prop ) ;
  //NumericVector time_increment = -(1/Ptotal)*log( runif ( nsimultaneous_picks ) ) ;  
  return ( wrap( cumP ) ) ;
}
')





